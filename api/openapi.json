{
  "openapi": "3.0.3",
  "info": {
    "title": "MIRADOR-CORE API",
    "description": "Advanced Observability Platform REST API",
    "version": "6.0.0",
    "contact": {
      "name": "Platformbuilds Team",
      "email": "rv@platformbuilds.org"
    }
  },
  "servers": [
    {
      "url": "{scheme}://{host}{basePath}",
      "description": "Configurable server (edit variables in Swagger UI)",
      "variables": {
        "scheme": {
          "enum": [
            "http",
            "https"
          ],
          "default": "http"
        },
        "host": {
          "default": "127.0.0.1:8010",
          "description": "Hostname:port of mirador-core"
        },
        "basePath": {
          "default": "/api/v1",
          "description": "Base path for API routes (use \"/\" for root-only endpoints)"
        }
      }
    }
  ],
  "components": {
    "securitySchemes": {
      "BearerAuth": {
        "type": "http",
        "scheme": "bearer",
        "description": "Session token from LDAP/AD or SSO"
      }
    },
    "schemas": {
      "SystemFracture": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "component": {
            "type": "string"
          },
          "fracture_type": {
            "type": "string",
            "enum": [
              "fatigue",
              "overload",
              "degradation"
            ]
          },
          "time_to_fracture": {
            "type": "integer",
            "description": "Seconds until predicted fracture"
          },
          "severity": {
            "type": "string",
            "enum": [
              "high",
              "medium",
              "low"
            ]
          },
          "probability": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          },
          "confidence": {
            "type": "number",
            "minimum": 0,
            "maximum": 1
          }
        }
      },
      "CorrelationResult": {
        "type": "object",
        "properties": {
          "correlation_id": {
            "type": "string"
          },
          "root_cause": {
            "type": "string"
          },
          "confidence": {
            "type": "number"
          },
          "red_anchors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RedAnchor"
            }
          }
        }
      },
      "RedAnchor": {
        "type": "object",
        "description": "Anomaly score pattern for RCA analysis",
        "properties": {
          "service": {
            "type": "string"
          },
          "metric": {
            "type": "string"
          },
          "anomaly_score": {
            "type": "number"
          },
          "threshold": {
            "type": "number"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "data_type": {
            "type": "string",
            "enum": [
              "metrics",
              "logs",
              "traces"
            ]
          }
        }
      },
      "ServiceGraphRequest": {
        "type": "object",
        "required": [
          "start",
          "end"
        ],
        "properties": {
          "start": {
            "type": "string",
            "format": "date-time",
            "description": "Start of the evaluation window (RFC3339)"
          },
          "end": {
            "type": "string",
            "format": "date-time",
            "description": "End of the evaluation window (RFC3339)"
          },
          "client": {
            "type": "string",
            "description": "Optional client service filter"
          },
          "server": {
            "type": "string",
            "description": "Optional server service filter"
          },
          "connection_type": {
            "type": "string",
            "description": "Optional connection type filter (for example \"http\")"
          }
        }
      },
      "ServiceGraphLatency": {
        "type": "object",
        "properties": {
          "avg_ms": {
            "type": "number",
            "format": "double",
            "description": "Average latency in milliseconds over the selected window"
          }
        }
      },
      "ServiceGraphEdge": {
        "type": "object",
        "properties": {
          "source": {
            "type": "string",
            "description": "Client service emitting the request"
          },
          "target": {
            "type": "string",
            "description": "Server service handling the request"
          },
          "connection_type": {
            "type": "string",
            "description": "Connection type inferred by the servicegraph connector"
          },
          "call_count": {
            "type": "number",
            "format": "double",
            "description": "Total calls between the services over the window"
          },
          "call_rate": {
            "type": "number",
            "format": "double",
            "description": "Average calls per minute during the window"
          },
          "error_count": {
            "type": "number",
            "format": "double",
            "description": "Failed calls over the window"
          },
          "error_rate": {
            "type": "number",
            "format": "double",
            "description": "Percentage of failed calls over total calls"
          },
          "server_latency_ms": {
            "$ref": "#/components/schemas/ServiceGraphLatency"
          },
          "client_latency_ms": {
            "$ref": "#/components/schemas/ServiceGraphLatency"
          },
          "unpaired_spans": {
            "type": "number",
            "format": "double",
            "description": "Count of unpaired spans contributing to the edge"
          },
          "dropped_spans": {
            "type": "number",
            "format": "double",
            "description": "Count of dropped spans while building the edge"
          }
        }
      },
      "ServiceGraphWindow": {
        "type": "object",
        "properties": {
          "start": {
            "type": "string",
            "format": "date-time"
          },
          "end": {
            "type": "string",
            "format": "date-time"
          },
          "duration_seconds": {
            "type": "integer",
            "description": "Duration of the evaluation window in seconds"
          }
        }
      },
      "ServiceGraphResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          },
          "generated_at": {
            "type": "string",
            "format": "date-time"
          },
          "window": {
            "$ref": "#/components/schemas/ServiceGraphWindow"
          },
          "edges": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ServiceGraphEdge"
            }
          }
        }
      },
      "FlameNode": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "value": {
            "type": "integer",
            "description": "Duration in ms"
          },
          "spanId": {
            "type": "string"
          },
          "service": {
            "type": "string"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FlameNode"
            }
          }
        }
      },
      "MetricsQLFunctionRequest": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "The MetricsQL query expression to aggregate"
          },
          "params": {
            "type": "object",
            "description": "Optional parameters for the aggregate function (e.g., quantile value, k value for topk/bottomk)",
            "additionalProperties": true
          }
        },
        "required": [
          "query"
        ]
      },
      "MetricsQLFunctionRangeRequest": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "The MetricsQL query expression to aggregate"
          },
          "start": {
            "type": "string",
            "format": "date-time",
            "description": "Start time for the range query (RFC3339 format)"
          },
          "end": {
            "type": "string",
            "format": "date-time",
            "description": "End time for the range query (RFC3339 format)"
          },
          "step": {
            "type": "string",
            "description": "Step duration for the range query (e.g., \"15s\", \"1m\", \"1h\")"
          },
          "params": {
            "type": "object",
            "description": "Optional parameters for the aggregate function (e.g., quantile value, k value for topk/bottomk)",
            "additionalProperties": true
          }
        },
        "required": [
          "query",
          "start",
          "end",
          "step"
        ]
      },
      "MetricsQLQueryResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string",
            "enum": [
              "success",
              "error"
            ]
          },
          "data": {
            "type": "object",
            "properties": {
              "result": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "metric": {
                      "type": "object",
                      "additionalProperties": true
                    },
                    "value": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      },
                      "description": "Array containing [timestamp, value] pair"
                    }
                  }
                }
              },
              "resultType": {
                "type": "string",
                "enum": [
                  "vector",
                  "matrix",
                  "scalar",
                  "string"
                ]
              }
            }
          },
          "error": {
            "type": "string",
            "description": "Error message if status is 'error'"
          },
          "errorType": {
            "type": "string",
            "description": "Type of error if status is 'error'"
          }
        }
      },
      "TraceServiceRequest": {
        "type": "object",
        "properties": {
          "tenantId": {
            "type": "string",
            "description": "Optional tenant ID (defaults to request tenant)"
          },
          "service": {
            "type": "string",
            "description": "Service name"
          },
          "purpose": {
            "type": "string",
            "description": "Service purpose/description"
          },
          "owner": {
            "type": "string",
            "description": "Service owner"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Flat list of tags (e.g., \"key:value\" or free-form labels)",
            "example": [
              "environment:production",
              "team:platform",
              "version:1.2.3"
            ]
          },
          "author": {
            "type": "string",
            "description": "Author of this change"
          }
        },
        "required": [
          "service"
        ]
      },
      "TraceOperationRequest": {
        "type": "object",
        "properties": {
          "tenantId": {
            "type": "string",
            "description": "Optional tenant ID (defaults to request tenant)"
          },
          "service": {
            "type": "string",
            "description": "Service name"
          },
          "operation": {
            "type": "string",
            "description": "Operation name"
          },
          "purpose": {
            "type": "string",
            "description": "Operation purpose/description"
          },
          "owner": {
            "type": "string",
            "description": "Operation owner"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Flat list of tags",
            "example": [
              "GET",
              "/api/v1/users",
              "30s"
            ]
          },
          "author": {
            "type": "string",
            "description": "Author of this change"
          }
        },
        "required": [
          "service",
          "operation"
        ]
      },
      "MetricRequest": {
        "type": "object",
        "properties": {
          "tenantId": {
            "type": "string",
            "description": "Optional tenant ID (defaults to request tenant)"
          },
          "metric": {
            "type": "string",
            "description": "Metric name"
          },
          "description": {
            "type": "string",
            "description": "Metric description"
          },
          "owner": {
            "type": "string",
            "description": "Metric owner"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Flat list of tags",
            "example": [
              "category:performance",
              "unit:seconds",
              "source:prometheus"
            ]
          },
          "author": {
            "type": "string",
            "description": "Author of this change"
          }
        },
        "required": [
          "metric"
        ]
      },
      "LogFieldRequest": {
        "type": "object",
        "properties": {
          "tenantId": {
            "type": "string",
            "description": "Optional tenant ID (defaults to request tenant)"
          },
          "field": {
            "type": "string",
            "description": "Log field name"
          },
          "type": {
            "type": "string",
            "description": "Field data type"
          },
          "description": {
            "type": "string",
            "description": "Field description"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Flat list of tags",
            "example": [
              "category:security",
              "format:json",
              "indexed:true"
            ]
          },
          "examples": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Example values as key-value string pairs",
            "example": {
              "normal": "INFO",
              "error": "ERROR",
              "debug": "DEBUG"
            }
          },
          "author": {
            "type": "string",
            "description": "Author of this change"
          }
        },
        "required": [
          "field"
        ]
      },
      "LabelRequest": {
        "type": "object",
        "properties": {
          "tenantId": {
            "type": "string",
            "description": "Optional tenant ID (defaults to request tenant)"
          },
          "name": {
            "type": "string",
            "description": "Label name (e.g., instance)"
          },
          "type": {
            "type": "string",
            "description": "Data type (string, number, bool, etc.)"
          },
          "required": {
            "type": "boolean"
          },
          "allowedValues": {
            "type": "object",
            "additionalProperties": true,
            "description": "Optional allowed set or constraints map"
          },
          "description": {
            "type": "string"
          },
          "author": {
            "type": "string",
            "description": "Author of this change"
          }
        },
        "required": [
          "name"
        ]
      },
      "GRPCEndpointsConfig": {
        "type": "object",
        "properties": {
          "rca_endpoint": {
            "type": "string",
            "description": "Endpoint URL for the RCA (Root Cause Analysis) gRPC service",
            "example": "rca-service:50051"
          },
          "predict_endpoint": {
            "type": "string",
            "description": "Endpoint URL for the PREDICT gRPC service",
            "example": "predict-service:50052"
          },
          "alerts_endpoint": {
            "type": "string",
            "description": "Endpoint URL for the ALERTS gRPC service",
            "example": "alerts-service:50053"
          }
        },
        "required": [
          "rca_endpoint",
          "predict_endpoint",
          "alerts_endpoint"
        ]
      },
      "GRPCEndpointsUpdateRequest": {
        "type": "object",
        "properties": {
          "rca_endpoint": {
            "type": "string",
            "description": "New endpoint URL for the RCA gRPC service",
            "example": "rca-service-new:50051"
          },
          "predict_endpoint": {
            "type": "string",
            "description": "New endpoint URL for the PREDICT gRPC service",
            "example": "predict-service-new:50052"
          },
          "alerts_endpoint": {
            "type": "string",
            "description": "New endpoint URL for the ALERTS gRPC service",
            "example": "alerts-service-new:50053"
          }
        },
        "additionalProperties": false,
        "description": "At least one endpoint must be provided for update"
      }
    }
  },
  "security": [
    {
      "BearerAuth": []
    }
  ],
  "paths": {
    "/health": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "Health check",
        "description": "Returns basic service health",
        "responses": {
          "200": {
            "description": "Healthy"
          }
        }
      }
    },
    "/ready": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "Readiness check",
        "description": "Checks backends (Victoria*, engines) and returns readiness",
        "responses": {
          "200": {
            "description": "Ready"
          },
          "503": {
            "description": "Not ready"
          }
        }
      }
    },
    "/microservices/status": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "Microservices status",
        "description": "Returns detailed status of all microservices",
        "responses": {
          "200": {
            "description": "Microservices status"
          }
        }
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "metrics"
        ],
        "summary": "Prometheus metrics",
        "description": "Exposes Prometheus metrics for monitoring",
        "responses": {
          "200": {
            "description": "Prometheus metrics data"
          }
        }
      }
    },
    "/predict/analyze": {
      "post": {
        "tags": [
          "predict"
        ],
        "summary": "Analyze system fractures",
        "description": "Predict possible fracture/fatigue in running services",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "component": {
                    "type": "string"
                  },
                  "time_range": {
                    "type": "string"
                  },
                  "model_types": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Fracture analysis results",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "fractures": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/SystemFracture"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/rca/investigate": {
      "post": {
        "tags": [
          "rca"
        ],
        "summary": "Start RCA investigation",
        "description": "Correlate incidents using red anchors pattern across metrics, logs, traces",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "incident_id": {
                    "type": "string"
                  },
                  "symptoms": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "time_range": {
                    "type": "object",
                    "properties": {
                      "start": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "end": {
                        "type": "string",
                        "format": "date-time"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "RCA correlation results",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CorrelationResult"
                }
              }
            }
          }
        }
      }
    },
    "/predict/health": {
      "get": {
        "tags": [
          "predict"
        ],
        "summary": "Predict Engine health",
        "responses": {
          "200": {
            "description": "Healthy"
          }
        }
      }
    },
    "/predict/fractures": {
      "get": {
        "tags": [
          "predict"
        ],
        "summary": "List predicted fractures",
        "parameters": [
          {
            "in": "query",
            "name": "time_range",
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "min_prob",
            "schema": {
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/predict/models": {
      "get": {
        "tags": [
          "predict"
        ],
        "summary": "List active prediction models",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/schema/traces/services": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert trace service definition",
        "description": "Create or update a trace service definition and record a new version.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TraceServiceRequest"
              },
              "example": {
                "service": "otelgen",
                "purpose": "this is a test service created by otelgen tool",
                "owner": "aarvee",
                "tags": [
                  "development",
                  "bda"
                ],
                "author": "aarvee"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/traces/services/bulk": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Bulk upsert trace services via CSV",
        "description": "Upload a CSV to create/update trace service definitions.\nCSV columns (header required; strict header mode):\n- tenantId (optional; defaults to request tenant)\n- service (required)\n- servicePurpose, owner, tags (JSON array), author\nSecurity: 5MiB payload limit, MIME allowlist with sniffing, UTF‑8 validation, CSV injection mitigation, no disk writes.\nLimits: header strict mode (reject unknown columns), 10k row cap, per‑tenant daily quota (429 on exceed).\n",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "429": {
            "description": "Too Many Requests"
          }
        }
      }
    },
    "/schema/traces/services/{service}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get current trace service definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not found"
          }
        }
      },
      "delete": {
        "tags": [
          "schema"
        ],
        "summary": "Delete trace service definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "confirm",
            "schema": {
              "type": "string"
            },
            "description": "Must be '1', 'true', or 'yes'"
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Failed to delete"
          }
        }
      }
    },
    "/schema/traces/services/{service}/versions": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "List versions for a trace service",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/schema/traces/services/{service}/versions/{version}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get a specific version of a trace service definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not found"
          }
        }
      }
    },
    "/schema/traces/operations": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert trace operation definition",
        "description": "Create or update a trace operation definition and record a new version.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TraceOperationRequest"
              },
              "example": {
                "service": "otelgen",
                "operation": "handle_request",
                "purpose": "handles incoming HTTP requests",
                "owner": "aarvee",
                "tags": [
                  "POST",
                  "/api/v1/data",
                  "30s"
                ],
                "author": "aarvee"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/traces/operations/bulk": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Bulk upsert trace operations via CSV",
        "description": "Upload a CSV to create/update trace operation definitions. Operations are scoped per service; rows referencing undefined services are rejected.\nCSV columns (header required; strict header mode):\n- tenantId (optional; defaults to request tenant)\n- service (required)\n- operation (required)\n- servicePurpose, owner, tags (JSON array), author\nSecurity: 5MiB payload limit, MIME allowlist with sniffing, UTF‑8 validation, CSV injection mitigation, no disk writes.\nLimits: header strict mode (reject unknown columns), 10k row cap, per‑tenant daily quota (429 on exceed).\n",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "429": {
            "description": "Too Many Requests"
          }
        }
      }
    },
    "/schema/traces/services/{service}/operations/{operation}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get current trace operation definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not found"
          }
        }
      },
      "delete": {
        "tags": [
          "schema"
        ],
        "summary": "Delete trace operation definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "confirm",
            "schema": {
              "type": "string"
            },
            "description": "Must be '1', 'true', or 'yes'"
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Failed to delete"
          }
        }
      }
    },
    "/schema/traces/services/{service}/operations/{operation}/versions": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "List versions for a trace operation",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/schema/traces/services/{service}/operations/{operation}/versions/{version}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get a specific version of a trace operation definition",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not found"
          }
        }
      }
    },
    "/schema/metrics": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert metric definition",
        "description": "Create or update a metric definition and record a new version.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "metric"
                ],
                "properties": {
                  "tenantId": {
                    "type": "string"
                  },
                  "metric": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "owner": {
                    "type": "string"
                  },
                  "tags": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "category": {
                    "type": "string"
                  },
                  "sentiment": {
                    "type": "string"
                  },
                  "author": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/metrics/bulk": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Bulk upsert metric and label definitions (CSV)",
        "description": "Upload a CSV to create/update metric and label definitions.\nSecurity: payload limited to 5MiB, MIME allowlist, UTF‑8 validation, and CSV injection mitigations.\n\nColumns (header required):\n\n- tenantId (optional; defaults to authenticated tenant)\n- metric (required)\n- description\n- owner\n- tags (JSON array)\n- category\n- sentiment\n- label\n- labelType\n- labelRequired (true/false/1/0/yes/no)\n- labelAllowed (JSON object)\n- labelDescription\n- author\n\nNote: Use the sample endpoint below to generate a pre-filled template.\n",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "required": [
                  "file"
                ],
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/metrics/bulk/sample": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Download sample CSV template",
        "description": "Generates a CSV with header and rows per metric/label to guide users.\n- If `metrics` is omitted, the server enumerates all metric names (via `__name__`) and includes a row per discovered label.\n- If `metrics` is provided (comma-separated), only those metrics are included.\n",
        "parameters": [
          {
            "in": "query",
            "name": "metrics",
            "required": false,
            "schema": {
              "type": "string"
            },
            "description": "Comma-separated metric names to include in the sample"
          }
        ],
        "responses": {
          "200": {
            "description": "CSV",
            "content": {
              "text/csv": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/schema/metrics/{metric}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get metric definition",
        "parameters": [
          {
            "in": "path",
            "name": "metric",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "delete": {
        "tags": [
          "schema"
        ],
        "summary": "Delete metric definition",
        "parameters": [
          {
            "in": "path",
            "name": "metric",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "confirm",
            "schema": {
              "type": "string"
            },
            "description": "Must be '1', 'true', or 'yes'"
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Failed to delete"
          }
        }
      }
    },
    "/schema/metrics/{metric}/versions": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "List metric definition versions",
        "parameters": [
          {
            "in": "path",
            "name": "metric",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "version": {
                            "type": "integer"
                          },
                          "author": {
                            "type": "string"
                          },
                          "created_at": {
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/schema/metrics/{metric}/versions/{version}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get specific metric definition version",
        "parameters": [
          {
            "in": "path",
            "name": "metric",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/schema/metrics/{metric}/labels": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert metric label definition",
        "description": "Create or update a label definition for a specific metric and record a new version.",
        "parameters": [
          {
            "in": "path",
            "name": "metric",
            "required": true,
            "schema": {
              "type": "string"
            },
            "description": "The metric name"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "label"
                ],
                "properties": {
                  "tenantId": {
                    "type": "string",
                    "description": "Optional tenant ID (defaults to request tenant)"
                  },
                  "label": {
                    "type": "string",
                    "description": "Label name"
                  },
                  "type": {
                    "type": "string",
                    "description": "Data type (string",
                    "number": null,
                    "bool": null,
                    "etc.)": null
                  },
                  "required": {
                    "type": "boolean",
                    "description": "Whether the label is required"
                  },
                  "allowedValues": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Optional allowed set or constraints map"
                  },
                  "description": {
                    "type": "string",
                    "description": "Label description"
                  },
                  "author": {
                    "type": "string",
                    "description": "Author of this change"
                  }
                }
              },
              "example": {
                "label": "instance",
                "type": "string",
                "required": false,
                "allowedValues": {},
                "description": "Pod or host instance label",
                "author": "aarvee"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "500": {
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/schema/labels": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert label definition (independent)",
        "description": "Create or update a label definition (not tied to a metric) and record a new version.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LabelRequest"
              },
              "example": {
                "name": "instance",
                "type": "string",
                "required": false,
                "allowedValues": {},
                "description": "Pod or host instance label",
                "author": "aarvee"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/labels/{name}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get label definition",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "delete": {
        "tags": [
          "schema"
        ],
        "summary": "Delete label definition",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "confirm",
            "schema": {
              "type": "string"
            },
            "description": "Must be '1', 'true', or 'yes'"
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Failed to delete"
          }
        }
      }
    },
    "/schema/labels/{name}/versions": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "List label definition versions",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "version": {
                            "type": "integer"
                          },
                          "author": {
                            "type": "string"
                          },
                          "created_at": {
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/schema/labels/{name}/versions/{version}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get specific label definition version",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/schema/labels/bulk": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Bulk upsert label definitions (CSV)",
        "description": "Upload a CSV to create/update label definitions.\nSecurity: 5MiB payload limit, MIME allowlist, UTF‑8 validation, CSV injection mitigation, daily per‑tenant quota.\n\nColumns (header required):\n- tenantId (optional)\n- name (required)\n- type\n- required (true/false/1/0/yes/no)\n- allowed (JSON object)\n- description\n- author\n",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "required": [
                  "file"
                ],
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "429": {
            "description": "Too Many Requests"
          }
        }
      }
    },
    "/schema/labels/bulk/sample": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Download sample CSV template for labels",
        "description": "Generates a CSV with header and example rows for common labels.",
        "responses": {
          "200": {
            "description": "CSV",
            "content": {
              "text/csv": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/schema/logs/fields": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Upsert log field definition",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "field"
                ],
                "properties": {
                  "tenantId": {
                    "type": "string"
                  },
                  "field": {
                    "type": "string"
                  },
                  "type": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  },
                  "category": {
                    "type": "string"
                  },
                  "sentiment": {
                    "type": "string"
                  },
                  "tags": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "author": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          }
        }
      }
    },
    "/schema/logs/fields/bulk": {
      "post": {
        "tags": [
          "schema"
        ],
        "summary": "Bulk upsert log field definitions (CSV)",
        "description": "Upload a CSV to create/update log field definitions.\nSecurity: 5MiB payload limit, MIME allowlist, UTF‑8 validation, CSV injection mitigation, daily per‑tenant quota.\n\nColumns (header required):\n- tenantId (optional)\n- category (optional)\n- logFieldName (required)\n- logFieldType (optional)\n- logFieldDefinition (optional)\n- sentiment (optional)\n- tags (optional, JSON array)\n- author (optional)\n",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "required": [
                  "file"
                ],
                "properties": {
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          },
          "400": {
            "description": "Bad Request"
          },
          "429": {
            "description": "Too Many Requests"
          }
        }
      }
    },
    "/schema/logs/fields/bulk/sample": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Download sample CSV template for log fields",
        "description": "Generates a CSV with header and one row per discovered log field.",
        "responses": {
          "200": {
            "description": "CSV",
            "content": {
              "text/csv": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/schema/logs/fields/{field}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get log field definition",
        "parameters": [
          {
            "in": "path",
            "name": "field",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "delete": {
        "tags": [
          "schema"
        ],
        "summary": "Delete log field definition",
        "parameters": [
          {
            "in": "path",
            "name": "field",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "confirm",
            "schema": {
              "type": "string"
            },
            "description": "Must be '1', 'true', or 'yes'"
          }
        ],
        "responses": {
          "200": {
            "description": "Deleted"
          },
          "404": {
            "description": "Not Found"
          },
          "500": {
            "description": "Failed to delete"
          }
        }
      }
    },
    "/schema/logs/fields/{field}/versions": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "List log field definition versions",
        "parameters": [
          {
            "in": "path",
            "name": "field",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "versions": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "version": {
                            "type": "integer"
                          },
                          "author": {
                            "type": "string"
                          },
                          "created_at": {
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/schema/logs/fields/{field}/versions/{version}": {
      "get": {
        "tags": [
          "schema"
        ],
        "summary": "Get specific log field definition version",
        "parameters": [
          {
            "in": "path",
            "name": "field",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "path",
            "name": "version",
            "required": true,
            "schema": {
              "type": "integer"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/rca/correlations": {
      "get": {
        "tags": [
          "rca"
        ],
        "summary": "Get active correlations",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rca/patterns": {
      "get": {
        "tags": [
          "rca"
        ],
        "summary": "Get failure patterns",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rca/service-graph": {
      "post": {
        "tags": [
          "rca"
        ],
        "summary": "Aggregate service graph metrics",
        "description": "Aggregates OpenTelemetry service graph metrics emitted by the\n`servicegraph` connector across every configured VictoriaMetrics source\nand returns the directed dependency edges for the requested window.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ServiceGraphRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Service graph edges",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceGraphResponse"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request"
          },
          "500": {
            "description": "Failed to fetch service graph"
          }
        }
      }
    },
    "/rca/store": {
      "post": {
        "tags": [
          "rca"
        ],
        "summary": "Store correlation event",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/series": {
      "get": {
        "deprecated": true,
        "summary": "Series listing (deprecated - use /metrics/series)",
        "description": "This endpoint is deprecated. Use /metrics/series instead.",
        "parameters": [
          {
            "in": "query",
            "name": "match",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form",
            "explode": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/labels": {
      "get": {
        "deprecated": true,
        "summary": "Labels listing (deprecated - use /metrics/labels)",
        "description": "This endpoint is deprecated. Use /metrics/labels instead.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/metrics/names": {
      "get": {
        "tags": [
          "metrics"
        ],
        "summary": "List metric names",
        "description": "Returns values of the special label `__name__` from VictoriaMetrics.",
        "parameters": [
          {
            "in": "query",
            "name": "start",
            "schema": {
              "type": "string"
            },
            "description": "Start time (RFC3339 or unix seconds)"
          },
          {
            "in": "query",
            "name": "end",
            "schema": {
              "type": "string"
            },
            "description": "End time (RFC3339 or unix seconds)"
          },
          {
            "in": "query",
            "name": "match[]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form",
            "explode": true,
            "description": "Optional label matchers"
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/metrics/series": {
      "get": {
        "tags": [
          "metrics"
        ],
        "summary": "Series listing",
        "description": "Returns a list of all time series that match the specified PromQL selectors.",
        "parameters": [
          {
            "in": "query",
            "name": "match[]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form",
            "explode": true,
            "description": "PromQL series selectors to filter time series"
          },
          {
            "in": "query",
            "name": "start",
            "schema": {
              "type": "string"
            },
            "description": "Start time (RFC3339 or unix seconds)"
          },
          {
            "in": "query",
            "name": "end",
            "schema": {
              "type": "string"
            },
            "description": "End time (RFC3339 or unix seconds)"
          }
        ],
        "responses": {
          "200": {
            "description": "List of time series with their label sets",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/metrics/labels": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Labels listing for a specific metric",
        "description": "Returns a list of label names that exist for the specified metric.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": [
                  "metric"
                ],
                "properties": {
                  "metric": {
                    "type": "string",
                    "description": "The metric name to get labels for"
                  },
                  "start": {
                    "type": "string",
                    "description": "Start time (RFC3339 or unix seconds)"
                  },
                  "end": {
                    "type": "string",
                    "description": "End time (RFC3339 or unix seconds)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "List of label names",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/label/{name}/values": {
      "get": {
        "tags": [
          "metrics"
        ],
        "summary": "Label values",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/metrics/query": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "MetricsQL instant query (VictoriaMetrics)",
        "description": "Executes an instant query against VictoriaMetrics using MetricsQL/PromQL syntax.\nWhen `include_definitions` is enabled (default), the response contains `definitions` sourced from the schema store\n(Weaviate) including metric and per-metric label definitions. Optional `label_keys` can limit which label keys are considered.\nWhen multiple metrics sources are configured in config.yaml (database.victoria_metrics + database.metrics_sources),\nthe server fans out the query across sources and aggregates the results. Identical series from different sources may appear as duplicates.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string"
                  },
                  "time": {
                    "type": "string"
                  },
                  "include_definitions": {
                    "type": "boolean",
                    "description": "Include definitions in response (default true)"
                  },
                  "label_keys": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Restrict definitions to these label keys"
                  }
                }
              },
              "example": {
                "query": "http_requests_total{job=\"api\"}",
                "time": "2025-01-01T00:00:00Z"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/metrics/query_range": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "MetricsQL range query (VictoriaMetrics)",
        "description": "Executes a range query. When `include_definitions` is enabled (default), the response contains\n`definitions` for metrics and per-metric label keys. Use `label_keys` to limit keys.\nWhen multiple metrics sources are configured, the server fans out the query and concatenates series across sources; datapoint counts are aggregated.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string"
                  },
                  "start": {
                    "type": "string"
                  },
                  "end": {
                    "type": "string"
                  },
                  "step": {
                    "type": "string"
                  },
                  "include_definitions": {
                    "type": "boolean",
                    "description": "Include definitions in response (default true)"
                  },
                  "label_keys": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Restrict definitions to these label keys"
                  }
                }
              },
              "example": {
                "query": "http_requests_total{job=\"api\"}",
                "start": "2025-01-01T00:00:00Z",
                "end": "2025-01-01T01:00:00Z",
                "step": "5m"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "example": {
                  "status": "success",
                  "data": {
                    "resultType": "matrix",
                    "result": [
                      {
                        "metric": {
                          "__name__": "http_requests_total",
                          "job": "api",
                          "instance": "pod-1"
                        },
                        "values": [
                          [
                            1690000000,
                            "1"
                          ],
                          [
                            1690000300,
                            "2"
                          ]
                        ]
                      }
                    ]
                  },
                  "metadata": {
                    "executionTime": 18,
                    "dataPoints": 2,
                    "timeRange": "1690000000 to 1690003600",
                    "step": 30
                  },
                  "definitions": {
                    "metrics": {
                      "http_requests_total": {
                        "description": "Total number of HTTP requests"
                      }
                    },
                    "labels": {
                      "http_requests_total": {
                        "instance": {
                          "type": "string",
                          "required": false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/rollup/{function}": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL rollup function",
        "description": "Executes a MetricsQL rollup function specified by the {function} path parameter. Supported functions include rate, increase, delta, irate, deriv, idelta, ideriv, absent_over_time, avg_over_time, min_over_time, max_over_time, sum_over_time, count_over_time, quantile_over_time, stddev_over_time, stdvar_over_time, mad_over_time, zscore_over_time, distinct_over_time, changes, resets, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "rate",
                "increase",
                "delta",
                "irate",
                "deriv",
                "idelta",
                "ideriv",
                "absent_over_time",
                "avg_over_time",
                "min_over_time",
                "max_over_time",
                "sum_over_time",
                "count_over_time",
                "quantile_over_time",
                "stddev_over_time",
                "stdvar_over_time",
                "mad_over_time",
                "zscore_over_time",
                "distinct_over_time",
                "changes",
                "resets",
                "rollup_candlestick"
              ]
            },
            "description": "The rollup function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRequest"
              },
              "examples": {
                "rate_example": {
                  "summary": "Calculate request rate per second",
                  "value": {
                    "query": "rate(http_requests_total[5m])"
                  }
                },
                "quantile_example": {
                  "summary": "Calculate 95th percentile over time",
                  "value": {
                    "query": "quantile_over_time(0.95, http_requests_total[1h])"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rollup function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/rollup/{function}/range": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL rollup function (range)",
        "description": "Executes a MetricsQL rollup function over a time range specified by the {function} path parameter. Supported functions include rate, increase, delta, irate, deriv, idelta, ideriv, absent_over_time, avg_over_time, min_over_time, max_over_time, sum_over_time, count_over_time, quantile_over_time, stddev_over_time, stdvar_over_time, mad_over_time, zscore_over_time, distinct_over_time, changes, resets, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "rate",
                "increase",
                "delta",
                "irate",
                "deriv",
                "idelta",
                "ideriv",
                "absent_over_time",
                "avg_over_time",
                "min_over_time",
                "max_over_time",
                "sum_over_time",
                "count_over_time",
                "quantile_over_time",
                "stddev_over_time",
                "stdvar_over_time",
                "mad_over_time",
                "zscore_over_time",
                "distinct_over_time",
                "changes",
                "resets",
                "rollup_candlestick"
              ]
            },
            "description": "The rollup function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRangeRequest"
              },
              "examples": {
                "rate_range_example": {
                  "summary": "Calculate request rate per second over time range",
                  "value": {
                    "query": "rate(http_requests_total[5m])",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "1m"
                  }
                },
                "quantile_range_example": {
                  "summary": "Calculate 95th percentile over time range",
                  "value": {
                    "query": "quantile_over_time(0.95, http_requests_total[1h])",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Rollup function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/transform/{function}": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL transform function",
        "description": "Executes a MetricsQL transform function specified by the {function} path parameter. Supported functions include abs, absent, ceil, clamp, clamp_max, clamp_min, day_of_month, day_of_week, days_in_month, deg, exp, floor, histogram_quantile, hour, ln, log10, log2, minute, month, pi, rad, rate, round, scalar, sgn, sin, sqrt, tan, time, timestamp, vector, year, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "abs",
                "absent",
                "ceil",
                "clamp",
                "clamp_max",
                "clamp_min",
                "day_of_month",
                "day_of_week",
                "days_in_month",
                "deg",
                "exp",
                "floor",
                "histogram_quantile",
                "hour",
                "ln",
                "log10",
                "log2",
                "minute",
                "month",
                "pi",
                "rad",
                "rate",
                "round",
                "scalar",
                "sgn",
                "sin",
                "sqrt",
                "tan",
                "time",
                "timestamp",
                "vector",
                "year",
                "label_replace",
                "label_join",
                "label_set",
                "label_keep",
                "label_drop",
                "label_match",
                "label_mismatch"
              ]
            },
            "description": "The transform function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRequest"
              },
              "examples": {
                "round_example": {
                  "summary": "Round values to nearest integer",
                  "value": {
                    "query": "round(http_requests_total)"
                  }
                },
                "clamp_example": {
                  "summary": "Clamp values between min and max",
                  "value": {
                    "query": "clamp(http_requests_total, 0, 100)",
                    "params": {
                      "min": 0,
                      "max": 100
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transform function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/transform/{function}/range": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL transform function (range)",
        "description": "Executes a MetricsQL transform function over a time range specified by the {function} path parameter. Supported functions include abs, absent, ceil, clamp, clamp_max, clamp_min, day_of_month, day_of_week, days_in_month, deg, exp, floor, histogram_quantile, hour, ln, log10, log2, minute, month, pi, rad, rate, round, scalar, sgn, sin, sqrt, tan, time, timestamp, vector, year, label_replace, label_join, label_set, label_keep, label_drop, label_match, label_mismatch]",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "abs",
                "absent",
                "ceil",
                "clamp",
                "clamp_max",
                "clamp_min",
                "day_of_month",
                "day_of_week",
                "days_in_month",
                "deg",
                "exp",
                "floor",
                "histogram_quantile",
                "hour",
                "ln",
                "log10",
                "log2",
                "minute",
                "month",
                "pi",
                "rad",
                "rate",
                "round",
                "scalar",
                "sgn",
                "sin",
                "sqrt",
                "tan",
                "time",
                "timestamp",
                "vector",
                "year",
                "label_replace",
                "label_join",
                "label_set",
                "label_keep",
                "label_drop",
                "label_match",
                "label_mismatch"
              ]
            },
            "description": "The transform function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRangeRequest"
              },
              "examples": {
                "round_range_example": {
                  "summary": "Round values over time range",
                  "value": {
                    "query": "round(http_requests_total)",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m"
                  }
                },
                "clamp_range_example": {
                  "summary": "Clamp values between min and max over time range",
                  "value": {
                    "query": "clamp(http_requests_total, 0, 100)",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m",
                    "params": {
                      "min": 0,
                      "max": 100
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Transform function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/aggregate/{function}": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL aggregate function",
        "description": "Executes a MetricsQL aggregate function specified by the {function} path parameter. Supported functions include sum, avg, count, min, max, stddev, stdvar, quantile, topk, bottomk, count_values, absent, increase, delta, rate, irate, deriv, idelta, ideriv, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "sum",
                "avg",
                "count",
                "min",
                "max",
                "stddev",
                "stdvar",
                "quantile",
                "topk",
                "bottomk",
                "count_values",
                "absent",
                "increase",
                "delta",
                "rate",
                "irate",
                "deriv",
                "idelta",
                "ideriv",
                "group",
                "histogram",
                "and",
                "or",
                "unless"
              ]
            },
            "description": "The aggregate function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRequest"
              },
              "examples": {
                "sum_example": {
                  "summary": "Sum all HTTP requests by job",
                  "value": {
                    "query": "sum(http_requests_total) by (job)"
                  }
                },
                "quantile_example": {
                  "summary": "Calculate 95th percentile of response times",
                  "value": {
                    "query": "quantile(0.95, http_request_duration_seconds)",
                    "params": {
                      "quantile": 0.95
                    }
                  }
                },
                "topk_example": {
                  "summary": "Get top 5 HTTP request rates",
                  "value": {
                    "query": "topk(5, rate(http_requests_total[5m]))",
                    "params": {
                      "k": 5
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Aggregate function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/aggregate/{function}/range": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL aggregate function (range)",
        "description": "Executes a MetricsQL aggregate function over a time range specified by the {function} path parameter. Supported functions include sum, avg, count, min, max, stddev, stdvar, quantile, topk, bottomk, count_values, absent, increase, delta, rate, irate, deriv, idelta, ideriv, group, histogram, and, or, unless]",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "sum",
                "avg",
                "count",
                "min",
                "max",
                "stddev",
                "stdvar",
                "quantile",
                "topk",
                "bottomk",
                "count_values",
                "absent",
                "increase",
                "delta",
                "rate",
                "irate",
                "deriv",
                "idelta",
                "ideriv",
                "group",
                "histogram",
                "and",
                "or",
                "unless"
              ]
            },
            "description": "The aggregate function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRangeRequest"
              },
              "examples": {
                "sum_range_example": {
                  "summary": "Sum HTTP requests by job over time range",
                  "value": {
                    "query": "sum(http_requests_total) by (job)",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m"
                  }
                },
                "quantile_range_example": {
                  "summary": "Calculate 95th percentile over time range",
                  "value": {
                    "query": "quantile(0.95, http_request_duration_seconds)",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "1m",
                    "params": {
                      "quantile": 0.95
                    }
                  }
                },
                "topk_range_example": {
                  "summary": "Get top 5 request rates over time range",
                  "value": {
                    "query": "topk(5, rate(http_requests_total[5m]))",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "1m",
                    "params": {
                      "k": 5
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Aggregate function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/label/{function}": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL label function",
        "description": "Executes a MetricsQL label function specified by the {function} path parameter. Supported functions include label_replace, label_join, label_set, label_keep, label_drop, label_match, label_mismatch, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "label_replace",
                "label_join",
                "label_set",
                "label_keep",
                "label_drop",
                "label_match",
                "label_mismatch"
              ]
            },
            "description": "The label function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRequest"
              },
              "examples": {
                "label_replace_example": {
                  "summary": "Replace label values using regex",
                  "value": {
                    "query": "label_replace(up, \"job\", \"$1\", \"instance\", \"(.*):.*\")",
                    "params": {
                      "dst": "job",
                      "replacement": "$1",
                      "src": "instance",
                      "regex": "(.*):.*"
                    }
                  }
                },
                "label_keep_example": {
                  "summary": "Keep only specific labels",
                  "value": {
                    "query": "label_keep(http_requests_total, \"job\", \"instance\")",
                    "params": {
                      "labels": [
                        "job",
                        "instance"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Label function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/query/label/{function}/range": {
      "post": {
        "tags": [
          "metrics"
        ],
        "summary": "Execute MetricsQL label function (range)",
        "description": "Executes a MetricsQL label function over a time range specified by the {function} path parameter. Supported functions include label_replace, label_join, label_set, label_keep, label_drop, label_match, label_mismatch, and more.",
        "parameters": [
          {
            "name": "function",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "enum": [
                "label_replace",
                "label_join",
                "label_set",
                "label_keep",
                "label_drop",
                "label_match",
                "label_mismatch"
              ]
            },
            "description": "The label function to execute"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MetricsQLFunctionRangeRequest"
              },
              "examples": {
                "label_replace_range_example": {
                  "summary": "Replace label values over time range",
                  "value": {
                    "query": "label_replace(up, \"job\", \"$1\", \"instance\", \"(.*):.*\")",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m",
                    "params": {
                      "dst": "job",
                      "replacement": "$1",
                      "src": "instance",
                      "regex": "(.*):.*"
                    }
                  }
                },
                "label_keep_range_example": {
                  "summary": "Keep specific labels over time range",
                  "value": {
                    "query": "label_keep(http_requests_total, \"job\", \"instance\")",
                    "start": "2025-01-01T00:00:00Z",
                    "end": "2025-01-01T01:00:00Z",
                    "step": "5m",
                    "params": {
                      "labels": [
                        "job",
                        "instance"
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Label function result",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricsQLQueryResponse"
                }
              }
            }
          }
        }
      }
    },
    "/logs/query": {
      "post": {
        "tags": [
          "logs"
        ],
        "summary": "LogsQL query (VictoriaLogs)",
        "description": "Accepts Lucene or Bleve expressions via `query` when `query_language` is `lucene` (or when auto-detected).\nSpecify `search_engine` as `bleve` to use Bleve search capabilities alongside existing Lucene functionality.\nMirador translates queries to VictoriaLogs query syntax.\nNote: Use either `_time` inside `query` or top-level `start`/`end`, not both. If both are provided, the\nserver prioritizes `_time` in `query` to avoid conflicting time filters.\nWhen multiple logs sources are configured in config.yaml (database.victoria_logs + database.logs_sources),\nthe server fans out the query and concatenates rows from all sources; the `fields` list is the union.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string",
                    "description": "LogsQL expression (e.g., `{service.name=\"telemetrygen\"} AND severity=\"Info\" AND _msg~\"message\"`)"
                  },
                  "query_language": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "logsql"
                    ],
                    "description": "If `lucene`, the server translates to VictoriaLogs query."
                  },
                  "search_engine": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "bleve"
                    ],
                    "description": "Search engine to use for query processing (default is lucene for backward compatibility)"
                  },
                  "start": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Start time in milliseconds since epoch"
                  },
                  "end": {
                    "type": "integer",
                    "format": "int64",
                    "description": "End time in milliseconds since epoch"
                  },
                  "limit": {
                    "type": "integer",
                    "description": "Max rows to return (default 1000)"
                  },
                  "tenantId": {
                    "type": "string",
                    "description": "Optional tenant override"
                  }
                }
              },
              "examples": {
                "lucene_query": {
                  "summary": "Query logs using Lucene syntax with Lucene search engine",
                  "value": {
                    "query_language": "lucene",
                    "search_engine": "lucene",
                    "query": "_time:[now-15m, now] AND service.name:telemetrygen AND severity:Info",
                    "limit": 200
                  }
                },
                "bleve_query": {
                  "summary": "Query logs using Lucene syntax with Bleve search engine",
                  "value": {
                    "query_language": "lucene",
                    "search_engine": "bleve",
                    "query": "_time:[now-15m, now] AND service.name:telemetrygen AND severity:Info",
                    "limit": 200
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/logs/streams": {
      "get": {
        "tags": [
          "logs"
        ],
        "summary": "Log streams",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/logs/fields": {
      "get": {
        "tags": [
          "logs"
        ],
        "summary": "Log fields",
        "description": "Returns only the union of field names derived from a hardcoded query over the last 10 minutes. Response contains only the fields array.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "fields": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/logs/export": {
      "post": {
        "tags": [
          "logs"
        ],
        "summary": "Export logs (streaming)",
        "description": "Streams a file attachment. Defaults to CSV when format is omitted. May convert JSON/NDJSON to CSV on the fly.\nAccepts Lucene via `query_language=lucene` and translates to VictoriaLogs query.\nNote: Use either `_time` inside `query` or top-level `start`/`end`, not both. If both are provided, the\nserver prioritizes `_time` in `query`.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string"
                  },
                  "query_language": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "logsql"
                    ]
                  },
                  "start": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "end": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "limit": {
                    "type": "integer"
                  },
                  "format": {
                    "type": "string",
                    "enum": [
                      "csv",
                      "json"
                    ]
                  }
                }
              },
              "example": {
                "query_language": "lucene",
                "query": "_time:[now-5m, now] AND level:error",
                "format": "csv"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "File stream",
            "content": {
              "text/csv": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          }
        }
      }
    },
    "/logs/store": {
      "post": {
        "tags": [
          "logs"
        ],
        "summary": "Store JSON event to logs",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/logs/histogram": {
      "get": {
        "tags": [
          "logs"
        ],
        "summary": "Histogram (D3)",
        "description": "Supports Lucene via `query_language=lucene` (server translates to VictoriaLogs query). Response shape unchanged\nfor D3. Note: Use either `_time` in `query` or top-level `start`/`end`, not both. If both are present, `_time`\nin `query` takes precedence.\n",
        "parameters": [
          {
            "in": "query",
            "name": "query_language",
            "schema": {
              "type": "string",
              "enum": [
                "lucene",
                "logsql"
              ]
            },
            "description": "If `lucene`, the server translates to VictoriaLogs query."
          },
          {
            "in": "query",
            "name": "query",
            "schema": {
              "type": "string"
            },
            "description": "Lucene expression for filtering logs",
            "example": "_time:[now-30m, now]"
          },
          {
            "in": "query",
            "name": "step",
            "schema": {
              "type": "integer",
              "format": "int64"
            },
            "description": "Bucket width in ms",
            "example": 60000
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "example": {
                  "buckets": [
                    {
                      "ts": 1737000000000,
                      "count": 42
                    },
                    {
                      "ts": 1737000060000,
                      "count": 30
                    }
                  ],
                  "stats": {
                    "buckets": 2,
                    "sampleN": 1
                  },
                  "sampled": false
                }
              }
            }
          }
        }
      }
    },
    "/logs/facets": {
      "get": {
        "tags": [
          "logs"
        ],
        "summary": "Facets (D3)",
        "description": "Supports Lucene via `query_language=lucene` (server translates to VictoriaLogs query). Response shape unchanged\nfor D3. Note: Use either `_time` in `query` or top-level `start`/`end`, not both. If both are present, `_time`\nin `query` takes precedence.\n",
        "parameters": [
          {
            "in": "query",
            "name": "query_language",
            "schema": {
              "type": "string",
              "enum": [
                "lucene",
                "logsql"
              ]
            },
            "description": "If `lucene`, the server translates to VictoriaLogs query."
          },
          {
            "in": "query",
            "name": "query",
            "schema": {
              "type": "string"
            },
            "description": "Lucene expression for filtering logs before faceting",
            "example": "_time:[now-30m, now] AND level:error"
          },
          {
            "in": "query",
            "name": "fields",
            "schema": {
              "type": "string"
            },
            "description": "Comma-separated fields to facet on",
            "example": "service,host"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "example": {
                  "facets": [
                    {
                      "field": "service",
                      "buckets": [
                        {
                          "key": "checkout",
                          "count": 120
                        },
                        {
                          "key": "api",
                          "count": 75
                        }
                      ]
                    }
                  ],
                  "stats": {
                    "fields": 1,
                    "sampleN": 1
                  },
                  "sampled": false
                }
              }
            }
          }
        }
      }
    },
    "/logs/search": {
      "post": {
        "tags": [
          "logs"
        ],
        "summary": "Search logs (D3)",
        "description": "Supports Lucene via `query_language=lucene`; translated to VictoriaLogs query. Note: Use either `_time` in\n`query` or top-level `start`/`end`, not both. If both are present, `_time` in `query` takes precedence.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string",
                    "description": "LogsQL expression (e.g., \"_time:5m service=web\")"
                  },
                  "query_language": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "logsql"
                    ]
                  },
                  "search_engine": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "bleve"
                    ],
                    "description": "Search engine to use for query processing (default is lucene for backward compatibility)"
                  },
                  "start": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Start time in ms since epoch"
                  },
                  "end": {
                    "type": "integer",
                    "format": "int64",
                    "description": "End time in ms since epoch"
                  },
                  "limit": {
                    "type": "integer",
                    "description": "Rows per page (default 1000, max 10000)"
                  },
                  "page_after": {
                    "type": "object",
                    "properties": {
                      "ts": {
                        "type": "integer",
                        "format": "int64",
                        "description": "Cursor timestamp (ms)"
                      },
                      "offset": {
                        "type": "integer",
                        "description": "Offset for same-ms rows"
                      }
                    }
                  },
                  "tenantId": {
                    "type": "string",
                    "description": "Optional tenant override"
                  }
                }
              },
              "examples": {
                "lucene_search": {
                  "summary": "Search logs using Lucene query syntax",
                  "value": {
                    "query_language": "lucene",
                    "query": "_time:15m AND level:error AND service:checkout",
                    "search_engine": "lucene",
                    "limit": 200
                  }
                },
                "bleve_search": {
                  "summary": "Search logs using Bleve query syntax",
                  "value": {
                    "query_language": "lucene",
                    "query": "_time:15m AND level:error AND service:checkout",
                    "search_engine": "bleve",
                    "limit": 200
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/logs/tail": {
      "get": {
        "tags": [
          "logs"
        ],
        "summary": "Tail logs (WebSocket)",
        "description": "Upgrades to a WebSocket connection and streams log rows as JSON frames.\nNote: Swagger \"Try it out\" sends a normal HTTP request and will not work here.\nUse a WebSocket client, for example:\n\n- wscat: `wscat -c ws://127.0.0.1:8010/api/v1/logs/tail?query=_time:5m&sampling=10`\n- websocat: `websocat -n ws://127.0.0.1:8010/api/v1/logs/tail?query=_time:5m`\n- Browser console: `new WebSocket(\"ws://127.0.0.1:8010/api/v1/logs/tail?query=_time:5m\")`\n\nQuery parameters:\n- `query`: LogsQL expression (e.g., `_time:5m`)\n- `since`: Start time in milliseconds since epoch (defaults to last 5 minutes)\n- `sampling`: Send every Nth row (integer, default 1)\n- `tenantId`: Optional tenant override\n",
        "parameters": [
          {
            "in": "query",
            "name": "query",
            "schema": {
              "type": "string"
            },
            "description": "LogsQL expression (e.g., `_time:5m`)"
          },
          {
            "in": "query",
            "name": "query_language",
            "schema": {
              "type": "string",
              "enum": [
                "lucene",
                "logsql"
              ]
            },
            "description": "If `lucene`, the server translates to VictoriaLogs query."
          },
          {
            "in": "query",
            "name": "since",
            "schema": {
              "type": "integer",
              "format": "int64"
            },
            "description": "Start timestamp in ms (defaults to now-5m)"
          },
          {
            "in": "query",
            "name": "sampling",
            "schema": {
              "type": "integer",
              "minimum": 1
            },
            "description": "Downsample by sending every Nth row (default 1)"
          },
          {
            "in": "query",
            "name": "tenantId",
            "schema": {
              "type": "string"
            },
            "description": "Optional tenant override for the request"
          }
        ],
        "responses": {
          "101": {
            "description": "Switching Protocols (WebSocket upgrade successful)"
          },
          "426": {
            "description": "Upgrade Required — endpoint must be called via WebSocket (not HTTP)"
          }
        }
      }
    },
    "/traces/services": {
      "get": {
        "tags": [
          "traces"
        ],
        "summary": "List services (VictoriaTraces/Jaeger)",
        "description": "Returns the union of services when multiple traces sources are configured (database.victoria_traces + database.traces_sources).",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/traces/services/{service}/operations": {
      "get": {
        "tags": [
          "traces"
        ],
        "summary": "List operations for a service",
        "parameters": [
          {
            "in": "path",
            "name": "service",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/traces/{traceId}": {
      "get": {
        "tags": [
          "traces"
        ],
        "summary": "Get trace by ID",
        "description": "Returns the first matching trace across configured sources when multiple traces sources are present.",
        "parameters": [
          {
            "in": "path",
            "name": "traceId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/traces/{traceId}/flamegraph": {
      "get": {
        "tags": [
          "traces"
        ],
        "summary": "Flame graph tree for a trace (D3)",
        "description": "Returns a hierarchical structure suitable for d3-flame-graph built from the Jaeger trace spans using CHILD_OF references.",
        "parameters": [
          {
            "in": "path",
            "name": "traceId",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "in": "query",
            "name": "mode",
            "schema": {
              "type": "string",
              "enum": [
                "duration",
                "self"
              ]
            },
            "description": "Node sizing mode. duration = total span duration; self = duration minus children durations (approximate)."
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string"
                        },
                        "value": {
                          "type": "integer"
                        },
                        "children": {
                          "type": "array",
                          "items": {
                            "$ref": "#/components/schemas/FlameNode"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/traces/flamegraph/search": {
      "post": {
        "tags": [
          "traces"
        ],
        "summary": "Aggregate flame graph over a traces search (D3)",
        "description": "Searches VictoriaTraces (Jaeger) and merges returned traces into a single flame graph tree. Useful for service-level flame graphs over a time window.",
        "parameters": [
          {
            "in": "query",
            "name": "mode",
            "schema": {
              "type": "string",
              "enum": [
                "duration",
                "self"
              ]
            },
            "description": "Node sizing mode. duration = total span duration; self = duration minus children durations (approximate)."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    },
                    "data": {
                      "$ref": "#/components/schemas/FlameNode"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/traces/search": {
      "post": {
        "tags": [
          "traces"
        ],
        "summary": "Search traces",
        "description": "Jaeger-compatible search across traces. This endpoint accepts Lucene or Bleve expressions via\n`query_language=lucene` and `query`, which Mirador translates into Jaeger filters (service,\noperation, tags, durations, and time window). Specify `search_engine` as `bleve` to use Bleve search capabilities.\nNote: Use either `_time` in `query` or top-level `start`/`end`,\nnot both. If both are provided, `_time` in `query` takes precedence. Alternatively, discover trace IDs via\n`/logs/search` with a Lucene filter on `trace_id`, then fetch traces by ID using `/traces/{traceId}`.\nWhen multiple traces sources are configured in config.yaml (database.victoria_traces + database.traces_sources),\nresults from all sources are concatenated.\n",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "query": {
                    "type": "string",
                    "description": "Optional Lucene expression (e.g., \"_time:[now-15m TO now] AND service:checkout AND operation:CreateOrder AND duration:[10ms TO *]\")"
                  },
                  "query_language": {
                    "type": "string",
                    "enum": [
                      "lucene"
                    ],
                    "description": "Set to `lucene` to enable translation"
                  },
                  "search_engine": {
                    "type": "string",
                    "enum": [
                      "lucene",
                      "bleve"
                    ],
                    "description": "Search engine to use for query processing (default is lucene for backward compatibility)"
                  },
                  "service": {
                    "type": "string"
                  },
                  "operation": {
                    "type": "string"
                  },
                  "tags": {
                    "type": "string",
                    "description": "Comma-separated key=value pairs"
                  },
                  "minDuration": {
                    "type": "string"
                  },
                  "maxDuration": {
                    "type": "string"
                  },
                  "start": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "end": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "limit": {
                    "type": "integer"
                  }
                }
              },
              "examples": {
                "lucene_search": {
                  "summary": "Search traces using Lucene query syntax",
                  "value": {
                    "query": "_time:[now-15m TO now] AND service:checkout AND operation:CreateOrder",
                    "query_language": "lucene",
                    "search_engine": "lucene",
                    "limit": 100
                  }
                },
                "bleve_search": {
                  "summary": "Search traces using Bleve query syntax",
                  "value": {
                    "query": "_time:[now-15m TO now] AND service:checkout AND operation:CreateOrder",
                    "query_language": "lucene",
                    "search_engine": "bleve",
                    "limit": 100
                  }
                },
                "lucene_with_tags": {
                  "summary": "Search traces with specific tags using Lucene",
                  "value": {
                    "query": "service:otelgen AND span.kind:client",
                    "query_language": "lucene",
                    "search_engine": "lucene",
                    "start": "2025-10-04T00:00:00.000Z",
                    "end": "2025-10-04T23:59:59.999Z",
                    "limit": 100
                  }
                },
                "bleve_with_tags": {
                  "summary": "Search traces with specific tags using Bleve",
                  "value": {
                    "query": "service:otelgen AND span.kind:client",
                    "query_language": "lucene",
                    "search_engine": "bleve",
                    "start": "2025-10-04T00:00:00.000Z",
                    "end": "2025-10-04T23:59:59.999Z",
                    "limit": 100
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/datasources": {
      "get": {
        "tags": [
          "config"
        ],
        "summary": "Get data sources",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "tags": [
          "config"
        ],
        "summary": "Add data source",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/user-settings": {
      "get": {
        "tags": [
          "config"
        ],
        "summary": "Get user settings",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "put": {
        "tags": [
          "config"
        ],
        "summary": "Update user settings",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/integrations": {
      "get": {
        "tags": [
          "config"
        ],
        "summary": "Get integrations config",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/features": {
      "get": {
        "tags": [
          "config"
        ],
        "summary": "Get runtime feature flags",
        "description": "Retrieve the current state of runtime feature flags for the tenant",
        "responses": {
          "200": {
            "description": "Feature flags retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "tenantId": {
                          "type": "string",
                          "description": "The tenant identifier"
                        },
                        "features": {
                          "type": "object",
                          "properties": {
                            "rca_enabled": {
                              "type": "boolean",
                              "description": "Whether RCA (Root Cause Analysis) features are enabled"
                            },
                            "predict_enabled": {
                              "type": "boolean",
                              "description": "Whether prediction engine features are enabled"
                            },
                            "user_settings_enabled": {
                              "type": "boolean",
                              "description": "Whether user settings features are enabled"
                            },
                            "rbac_enabled": {
                              "type": "boolean",
                              "description": "Whether RBAC (Role-Based Access Control) features are enabled"
                            }
                          },
                          "required": [
                            "rca_enabled",
                            "predict_enabled",
                            "user_settings_enabled",
                            "rbac_enabled"
                          ]
                        }
                      },
                      "required": [
                        "tenantId",
                        "features"
                      ]
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Timestamp of the response"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "tenantId": "default",
                    "features": {
                      "rca_enabled": true,
                      "predict_enabled": true,
                      "user_settings_enabled": true,
                      "rbac_enabled": true
                    }
                  },
                  "timestamp": "2025-10-19T13:46:07Z"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "config"
        ],
        "summary": "Update runtime feature flags",
        "description": "Update one or more runtime feature flags without restarting the service",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "features": {
                    "type": "object",
                    "properties": {
                      "rca_enabled": {
                        "type": "boolean",
                        "description": "Enable/disable RCA features"
                      },
                      "predict_enabled": {
                        "type": "boolean",
                        "description": "Enable/disable prediction engine features"
                      },
                      "user_settings_enabled": {
                        "type": "boolean",
                        "description": "Enable/disable user settings features"
                      },
                      "rbac_enabled": {
                        "type": "boolean",
                        "description": "Enable/disable RBAC features"
                      }
                    },
                    "additionalProperties": false,
                    "description": "Feature flags to update"
                  }
                },
                "required": [
                  "features"
                ]
              },
              "example": {
                "features": {
                  "rca_enabled": false,
                  "predict_enabled": true
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Feature flags updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "tenantId": {
                          "type": "string",
                          "description": "The tenant identifier"
                        },
                        "features": {
                          "type": "object",
                          "properties": {
                            "rca_enabled": {
                              "type": "boolean"
                            },
                            "predict_enabled": {
                              "type": "boolean"
                            },
                            "user_settings_enabled": {
                              "type": "boolean"
                            },
                            "rbac_enabled": {
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "rca_enabled",
                            "predict_enabled",
                            "user_settings_enabled",
                            "rbac_enabled"
                          ]
                        },
                        "updated": {
                          "type": "boolean",
                          "description": "Indicates if the flags were updated"
                        }
                      },
                      "required": [
                        "tenantId",
                        "features",
                        "updated"
                      ]
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "tenantId": "default",
                    "features": {
                      "rca_enabled": false,
                      "predict_enabled": true,
                      "user_settings_enabled": true,
                      "rbac_enabled": true
                    },
                    "updated": true
                  },
                  "timestamp": "2025-10-19T13:46:55Z"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format or unknown feature flag",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the validation failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                },
                "example": {
                  "status": "error",
                  "error": "Invalid feature flags format"
                }
              }
            }
          }
        }
      }
    },
    "/config/features/reset": {
      "post": {
        "tags": [
          "config"
        ],
        "summary": "Reset feature flags to defaults",
        "description": "Reset all runtime feature flags to their default enabled state",
        "responses": {
          "200": {
            "description": "Feature flags reset successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "tenantId": {
                          "type": "string",
                          "description": "The tenant identifier"
                        },
                        "features": {
                          "type": "object",
                          "properties": {
                            "rca_enabled": {
                              "type": "boolean"
                            },
                            "predict_enabled": {
                              "type": "boolean"
                            },
                            "user_settings_enabled": {
                              "type": "boolean"
                            },
                            "rbac_enabled": {
                              "type": "boolean"
                            }
                          },
                          "required": [
                            "rca_enabled",
                            "predict_enabled",
                            "user_settings_enabled",
                            "rbac_enabled"
                          ]
                        },
                        "reset": {
                          "type": "boolean",
                          "description": "Indicates if the flags were reset"
                        }
                      },
                      "required": [
                        "tenantId",
                        "features",
                        "reset"
                      ]
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "tenantId": "default",
                    "features": {
                      "rca_enabled": true,
                      "predict_enabled": true,
                      "user_settings_enabled": true,
                      "rbac_enabled": true
                    },
                    "reset": true
                  },
                  "timestamp": "2025-10-19T13:48:37Z"
                }
              }
            }
          },
          "500": {
            "description": "Failed to reset feature flags",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/config/grpc/endpoints": {
      "get": {
        "tags": [
          "config"
        ],
        "summary": "Get gRPC endpoint configurations",
        "description": "Retrieve the current gRPC endpoint configurations for RCA, PREDICT, and ALERTS services",
        "responses": {
          "200": {
            "description": "gRPC endpoints retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "$ref": "#/components/schemas/GRPCEndpointsConfig"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time",
                      "description": "Timestamp of the response"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "rca_endpoint": "rca-service:50051",
                    "predict_endpoint": "predict-service:50052",
                    "alerts_endpoint": "alerts-service:50053"
                  },
                  "timestamp": "2025-10-19T14:00:00Z"
                }
              }
            }
          },
          "500": {
            "description": "Failed to retrieve gRPC endpoints",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "config"
        ],
        "summary": "Update gRPC endpoint configurations",
        "description": "Update one or more gRPC endpoint configurations without restarting the service. The gRPC clients will dynamically reconnect to the new endpoints.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GRPCEndpointsUpdateRequest"
              },
              "example": {
                "rca_endpoint": "rca-service-new:50051",
                "predict_endpoint": "predict-service-new:50052"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "gRPC endpoints updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "tenantId": {
                          "type": "string",
                          "description": "The tenant identifier"
                        },
                        "endpoints": {
                          "$ref": "#/components/schemas/GRPCEndpointsConfig"
                        },
                        "updated": {
                          "type": "boolean",
                          "description": "Indicates if the endpoints were updated"
                        }
                      },
                      "required": [
                        "tenantId",
                        "endpoints",
                        "updated"
                      ]
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "tenantId": "default",
                    "endpoints": {
                      "rca_endpoint": "rca-service-new:50051",
                      "predict_endpoint": "predict-service-new:50052",
                      "alerts_endpoint": "alerts-service:50053"
                    },
                    "updated": true
                  },
                  "timestamp": "2025-10-19T14:05:00Z"
                }
              }
            }
          },
          "400": {
            "description": "Invalid request format or unknown endpoint",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the validation failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                },
                "example": {
                  "status": "error",
                  "error": "Invalid endpoint format"
                }
              }
            }
          },
          "500": {
            "description": "Failed to update gRPC endpoints",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/config/grpc/endpoints/reset": {
      "post": {
        "tags": [
          "config"
        ],
        "summary": "Reset gRPC endpoint configurations to defaults",
        "description": "Reset all gRPC endpoint configurations to their default values from the static configuration",
        "responses": {
          "200": {
            "description": "gRPC endpoints reset successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "success"
                      ]
                    },
                    "data": {
                      "type": "object",
                      "properties": {
                        "tenantId": {
                          "type": "string",
                          "description": "The tenant identifier"
                        },
                        "endpoints": {
                          "$ref": "#/components/schemas/GRPCEndpointsConfig"
                        },
                        "reset": {
                          "type": "boolean",
                          "description": "Indicates if the endpoints were reset"
                        }
                      },
                      "required": [
                        "tenantId",
                        "endpoints",
                        "reset"
                      ]
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "required": [
                    "status",
                    "data",
                    "timestamp"
                  ]
                },
                "example": {
                  "status": "success",
                  "data": {
                    "tenantId": "default",
                    "endpoints": {
                      "rca_endpoint": "rca-service:50051",
                      "predict_endpoint": "predict-service:50052",
                      "alerts_endpoint": "alerts-service:50053"
                    },
                    "reset": true
                  },
                  "timestamp": "2025-10-19T14:10:00Z"
                }
              }
            }
          },
          "500": {
            "description": "Failed to reset gRPC endpoints",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string",
                      "enum": [
                        "error"
                      ]
                    },
                    "error": {
                      "type": "string",
                      "description": "Error message describing the failure"
                    }
                  },
                  "required": [
                    "status",
                    "error"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/sessions/active": {
      "get": {
        "tags": [
          "sessions"
        ],
        "summary": "Get active sessions (current user)",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sessions/invalidate": {
      "post": {
        "tags": [
          "sessions"
        ],
        "summary": "Invalidate a session",
        "requestBody": {
          "required": false
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sessions/user/{userId}": {
      "get": {
        "tags": [
          "sessions"
        ],
        "summary": "Get sessions for a user",
        "parameters": [
          {
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rbac/roles": {
      "get": {
        "tags": [
          "rbac"
        ],
        "summary": "List roles",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "tags": [
          "rbac"
        ],
        "summary": "Create role",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rbac/users/{userId}/roles": {
      "put": {
        "tags": [
          "rbac"
        ],
        "summary": "Assign user roles",
        "parameters": [
          {
            "in": "path",
            "name": "userId",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ws/metrics": {
      "get": {
        "tags": [
          "ws"
        ],
        "summary": "Metrics stream (WebSocket)",
        "responses": {
          "101": {
            "description": "Switching Protocols"
          }
        }
      }
    },
    "/ws/alerts": {
      "get": {
        "tags": [
          "ws"
        ],
        "summary": "Alerts stream (WebSocket)",
        "responses": {
          "101": {
            "description": "Switching Protocols"
          }
        }
      }
    },
    "/ws/predictions": {
      "get": {
        "tags": [
          "ws"
        ],
        "summary": "Predictions stream (WebSocket)",
        "responses": {
          "101": {
            "description": "Switching Protocols"
          }
        }
      }
    }
  }
}