{
  "keydb_redis_top_10_kpis": [
    {
      "kpi_name": "Memory Utilization",
      "kpi_formula": "redis_memory_used_bytes / redis_memory_max_bytes * 100",
      "kpi_definition": "The percentage of total memory currently in use by KeyDB/Redis. High memory usage can lead to eviction of keys, slow performance, or out-of-memory errors causing service disruption.",
      "layer": "cause",
      "classifier": "memory_utilization",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Cache Hit Rate",
      "kpi_formula": "rate(redis_keyspace_hits_total[5m]) / (rate(redis_keyspace_hits_total[5m]) + rate(redis_keyspace_misses_total[5m])) * 100",
      "kpi_definition": "The percentage of key lookups that are served from memory instead of resulting in cache misses. Low hit rates indicate inefficient caching, wrong key patterns, or memory pressure causing evictions.",
      "layer": "cause",
      "classifier": "cache_efficiency",
      "sentiment": "positive",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Connected Clients",
      "kpi_formula": "redis_connected_clients",
      "kpi_definition": "The number of client connections currently active. High client counts may indicate connection pool issues, client leaks, or approaching the maximum connection limit which can cause new connection rejections.",
      "layer": "cause",
      "classifier": "connection_capacity",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Operations Per Second",
      "kpi_formula": "rate(redis_commands_processed_total[5m])",
      "kpi_definition": "The number of commands processed per second. Sudden drops may indicate performance issues, while sustained high rates may require scaling to handle the workload.",
      "layer": "cause",
      "classifier": "throughput",
      "sentiment": "neutral",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Blocked Clients",
      "kpi_formula": "redis_blocked_clients",
      "kpi_definition": "The number of clients blocked on operations like BLPOP, BRPOP, or BRPOPLPUSH. High numbers indicate slow operations or blocking commands that are tying up client connections.",
      "layer": "cause",
      "classifier": "client_blocking",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Key Eviction Rate",
      "kpi_formula": "rate(redis_evicted_keys_total[5m])",
      "kpi_definition": "The rate at which keys are being evicted due to memory pressure. High eviction rates indicate memory exhaustion and can lead to data loss and cache churn.",
      "layer": "cause",
      "classifier": "memory_pressure",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Replication Lag",
      "kpi_formula": "redis_master_repl_offset - redis_slave_repl_offset",
      "kpi_definition": "The difference in replication offset between master and replica nodes. High lag indicates replication delays, which can lead to data inconsistency if a replica is promoted.",
      "layer": "cause",
      "classifier": "replication_health",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Network Input/Output",
      "kpi_formula": "rate(redis_net_input_bytes_total[5m])",
      "kpi_definition": "The rate of data being received by the Redis server. Helps identify network bottlenecks and understand the data ingress patterns affecting performance.",
      "layer": "cause",
      "classifier": "network_throughput",
      "sentiment": "neutral",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "CPU Utilization",
      "kpi_formula": "rate(redis_cpu_sys_seconds_total[5m]) + rate(redis_cpu_user_seconds_total[5m])",
      "kpi_definition": "The CPU time spent by Redis in system and user mode. High CPU usage indicates computational bottlenecks, expensive commands, or single-threaded operation saturation in Redis.",
      "layer": "cause",
      "classifier": "cpu_utilization",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    },
    {
      "kpi_name": "Key Expiration Rate",
      "kpi_formula": "rate(redis_expired_keys_total[5m])",
      "kpi_definition": "The rate at which keys are expiring due to TTL settings. High expiration rates combined with high memory usage may indicate inefficient key expiration or memory fragmentation issues.",
      "layer": "cause",
      "classifier": "key_management",
      "sentiment": "negative",
      "signal_type": "metrics",
      "query_type": "PromQL",
      "datastore": "victoriametrics",
      "serviceFamily": "keydb"
    }
  ]
}
